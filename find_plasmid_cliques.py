#!/usr/bin/env python3
"""Identify plasmid groups sharing long high-identity blocks.

This script consumes the ``all_coords.tsv`` table generated by
:mod:`all_vs_all_nucmer.py` and identifies cliques of plasmids that share
blocks of at least a user-specified length and percent identity
(default 90%%).

For each clique a directory named ``group_XXkb_<n>`` is created containing
copies of the plasmid FASTA files.  Groups that are nearly identical to a
larger group (missing at most ``--max-missing`` members and covering at
least ``--overlap`` of the larger group) are recorded as alternatives and
named ``group_XXkb_<n>_alt<m>``.

Two reports are produced in the output directory:
``group_report.tsv`` summarising membership, and
``multi_group_members.tsv`` listing plasmids occurring in more than one
clique.  A third report ``group_gene_counts.tsv`` tabulates gene counts per
clique.  Genes are extracted from FASTA file names after the ``bla`` tag
(e.g. ``blaKPC2``).

Optionally a network plot can be generated where nodes are plasmids and
edges connect plasmids sharing a qualifying block.  Nodes can be coloured by
primary gene or by their main clique.  Plot aesthetics such as node size,
label size and spring layout parameters are configurable.
"""

from __future__ import annotations

import argparse
import csv
from collections import Counter, defaultdict
import shutil
from pathlib import Path
from typing import Dict, Iterable, List, Set

import matplotlib.pyplot as plt
import networkx as nx


def find_fasta_files(directory: Path) -> List[Path]:
    """Return a sorted list of FASTA files within *directory*."""
    exts = {".fa", ".fasta", ".fna", ".ffn"}
    return sorted(
        [p for p in directory.iterdir() if p.suffix.lower() in exts and p.is_file()]
    )


def parse_genes(filename: str) -> List[str]:
    """Extract gene names from a FASTA filename."""
    stem = Path(filename).stem
    if "bla" not in stem:
        return []
    gene_part = stem.split("bla", 1)[1]
    return gene_part.split("and")


def build_graph(coords_file: Path, min_len: int, min_id: float) -> nx.Graph:
    """Build a graph where edges join plasmids sharing qualifying blocks."""
    G = nx.Graph()
    with coords_file.open() as fh:
        reader = csv.DictReader(fh, delimiter="\t")
        for row in reader:
            ref = row["ref_file"]
            qry = row["query_file"]
            ident = float(row["%_IDY"])
            len1 = int(row["LEN_1"])
            len2 = int(row["LEN_2"])
            if ident >= min_id and min(len1, len2) >= min_len:
                G.add_edge(ref, qry)
    return G


def find_groups(
    G: nx.Graph, max_missing: int, overlap: float
) -> List[Dict[str, Iterable[Set[str]]]]:
    """Find maximal cliques and annotate alternative groups."""
    cliques = [set(c) for c in nx.find_cliques(G) if len(c) > 1]
    cliques.sort(key=len, reverse=True)

    groups: List[Dict[str, Iterable[Set[str]]]] = []
    for clique in cliques:
        is_alt = False
        for main in groups:
            main_members: Set[str] = main["members"]
            missing = len(main_members - clique)
            coverage = len(main_members & clique) / len(main_members)
            if missing <= max_missing and coverage >= overlap:
                main.setdefault("alts", []).append(clique)
                is_alt = True
                break
        if not is_alt:
            groups.append({"members": clique, "alts": []})
    return groups


def copy_files(members: Set[str], fasta_dir: Path, dest: Path) -> None:
    dest.mkdir(parents=True, exist_ok=True)
    for name in members:
        src = fasta_dir / name
        if src.exists():
            shutil.copy(src, dest / name)


def write_reports(
    outdir: Path,
    group_names: Dict[frozenset, str],
    groups: List[Dict[str, Iterable[Set[str]]]],
    genes: Dict[str, List[str]],
) -> None:
    group_report = outdir / "group_report.tsv"
    multi_report = outdir / "multi_group_members.tsv"
    gene_report = outdir / "group_gene_counts.tsv"

    plasmid_to_groups: Dict[str, List[str]] = defaultdict(list)

    with group_report.open("w") as gr, gene_report.open("w") as gg:
        gr.write("group\tsize\tmembers\n")
        gg.write("group\tgene\tcount\n")
        for grp in groups:
            main_name = group_names[frozenset(grp["members"])]
            members = sorted(grp["members"])
            gr.write(f"{main_name}\t{len(members)}\t{','.join(members)}\n")
            for m in members:
                plasmid_to_groups[m].append(main_name)
            counts = Counter(g for m in members for g in genes.get(m, []))
            for gene, count in counts.items():
                gg.write(f"{main_name}\t{gene}\t{count}\n")
            # alt groups
            for idx, alt in enumerate(grp["alts"], 1):
                alt_name = f"{main_name}_alt{idx}"
                alt_members = sorted(alt)
                gr.write(f"{alt_name}\t{len(alt_members)}\t{','.join(alt_members)}\n")
                for m in alt_members:
                    plasmid_to_groups[m].append(alt_name)
                counts = Counter(g for m in alt_members for g in genes.get(m, []))
                for gene, count in counts.items():
                    gg.write(f"{alt_name}\t{gene}\t{count}\n")

    with multi_report.open("w") as mr:
        mr.write("plasmid\tgroups\n")
        for plasmid, grps in plasmid_to_groups.items():
            if len(grps) > 1:
                mr.write(f"{plasmid}\t{','.join(sorted(grps))}\n")


def plot_graph(
    G: nx.Graph,
    genes: Dict[str, List[str]],
    group_color: Dict[str, str],
    args: argparse.Namespace,
) -> None:
    pos = nx.spring_layout(G, k=args.spring_k, iterations=args.spring_iterations, seed=42)

    if args.color_by == "gene":
        palette = plt.get_cmap("tab20")
        gene_names = sorted({g for gs in genes.values() for g in gs[:1]})
        color_map = {g: palette(i / max(1, len(gene_names) - 1)) for i, g in enumerate(gene_names)}
        node_colors = [color_map.get(genes.get(n, ["unknown"])[0], "lightgrey") for n in G.nodes]
    else:  # color by group
        node_colors = [group_color.get(n, "lightgrey") for n in G.nodes]

    nx.draw_networkx_edges(G, pos, alpha=0.5)
    nx.draw_networkx_nodes(G, pos, node_color=node_colors, node_size=args.node_size)
    if args.show_labels:
        nx.draw_networkx_labels(G, pos, font_size=args.label_size)

    if args.output_figure:
        plt.savefig(args.output_figure, bbox_inches="tight")
    else:
        plt.show()


def main() -> None:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("coords", type=Path, help="Path to all_coords.tsv")
    parser.add_argument("fasta_dir", type=Path, help="Directory containing plasmid FASTA files")
    parser.add_argument("--min-length", type=int, required=True, help="Minimum shared block length (bp)")
    parser.add_argument("--min-identity", type=float, default=90.0, help="Minimum percent identity")
    parser.add_argument("--output-dir", type=Path, default=Path("."), help="Directory for results")
    parser.add_argument("--max-missing", type=int, default=2, help="Maximum members missing to call alt group")
    parser.add_argument("--overlap", type=float, default=0.95, help="Fractional overlap to call alt group")
    parser.add_argument("--plot", action="store_true", help="Generate network plot")
    parser.add_argument("--color-by", choices=["gene", "group"], default="gene", help="Colour nodes by gene or group")
    parser.add_argument("--node-size", type=int, default=300, help="Node size for plot")
    parser.add_argument("--label-size", type=int, default=8, help="Label font size")
    parser.add_argument("--show-labels", action="store_true", help="Display node labels in plot")
    parser.add_argument("--spring-k", type=float, default=0.5, help="Spring layout repulsion constant")
    parser.add_argument("--spring-iterations", type=int, default=50, help="Iterations for spring layout")
    parser.add_argument("--output-figure", type=Path, help="Path to save network figure instead of showing")
    args = parser.parse_args()

    G = build_graph(args.coords, args.min_length, args.min_identity)

    # Ensure all plasmids appear as nodes
    fasta_files = find_fasta_files(args.fasta_dir)
    for f in fasta_files:
        G.add_node(f.name)

    genes = {f.name: parse_genes(f.name) for f in fasta_files}

    groups = find_groups(G, args.max_missing, args.overlap)

    length_kb = args.min_length // 1000
    group_names: Dict[frozenset, str] = {}
    group_color: Dict[str, str] = {}
    palette = plt.get_cmap("tab20")

    for idx, grp in enumerate(groups, 1):
        name = f"group_{length_kb}kb_{idx}"
        group_names[frozenset(grp["members"])] = name
        copy_files(grp["members"], args.fasta_dir, args.output_dir / name)
        color = palette((idx - 1) % 20)
        for m in grp["members"]:
            group_color.setdefault(m, color)
        for alt_idx, alt in enumerate(grp["alts"], 1):
            alt_name = f"{name}_alt{alt_idx}"
            copy_files(alt, args.fasta_dir, args.output_dir / alt_name)
            for m in alt:
                group_color.setdefault(m, color)

    write_reports(args.output_dir, group_names, groups, genes)

    if args.plot:
        plot_graph(G, genes, group_color, args)


if __name__ == "__main__":
    main()
